const { app, BrowserWindow, globalShortcut, screen, ipcMain } = require('electron');
const path = require('path');
const axios = require('axios'); 
const { spawn } = require('child_process');
const os = require('os');
const fs = require('fs');
const https = require('https'); 
const { Server } = require('ws'); 
const WebSocket = require('ws'); 
let wsClient; 

let store; 
let pollingInterval = null; // CRÍTICO: Variable para el intervalo de polling

const isDev = process.env.NODE_ENV === 'development';

app.commandLine.appendSwitch('ignore-certificate-errors'); 
app.disableHardwareAcceleration();

let overlayWindow;

const HTTP_BASE_URL = isDev ? 'http://localhost:3000' : 'https://lolmetamind-dmxt.onrender.com'; 
const WS_BASE_URL = isDev ? 'ws://localhost:8080' : 'wss://lolmetamind-ws.onrender.com'; 

const BACKEND_BASE_URL = HTTP_BASE_URL; 
const LIVE_GAME_UPDATE_ENDPOINT = '/api/live-game/update';
const LIVE_GAME_UPDATE_INTERVAL = 10000; // Polling cada 10 segundos

const lcuAgent = new https.Agent({
  rejectUnauthorized: false,
});

// --- FUNCIÓN DE DETECCIÓN DE LOCKFILE CORREGIDA ---
function getLcuCredentials() {
    // Rutas dinámicas (AppData, etc.)
    const appDataDir = process.env.LOCALAPPDATA || (
        process.platform === 'win32' 
        ? path.join(process.env.USERPROFILE, 'AppData', 'Local') 
        : process.platform === 'darwin' 
        ? path.join(process.env.HOME, 'Library', 'Application Support') 
        : path.join(process.env.HOME, '.config')
    );

    const possiblePaths = [
        // 1. RUTA CLÁSICA DE INSTALACIÓN FIJA (La que encontraste)
        'C:\\Riot Games\\League of Legends\\lockfile',
        
        // 2. OTRAS UNIDADES COMUNES (D: y E:)
        'D:\\Riot Games\\League of Legends\\lockfile',
        'E:\\Riot Games\\League of Legends\\lockfile',
        
        // 3. RUTA POR DEFECTO EN EL LOCAL APPDATA (Windows)
        path.join(appDataDir, 'Riot Games', 'League of Legends', 'lockfile'),
        
        // 4. RUTAS ALTERNAS (Riot Client AppData)
        path.join(appDataDir, 'riotclient', 'lockfile'),
    ];

    console.log(`[LCU] Buscando lockfile en ${possiblePaths.length} rutas conocidas.`);

    let lockfilePath = null;

    // Itera sobre todas las rutas hasta encontrar una
    for (const p of possiblePaths) {
        try {
            if (fs.existsSync(p)) {
                lockfilePath = p;
                console.log(`[LCU] ✅ Lockfile encontrado en: ${lockfilePath}`);
                break;
            }
        } catch (e) {
             // Ignorar errores de acceso temporal
        }
    }

    if (!lockfilePath) {
        return { error: 'El lockfile no existe. Asegúrate de que el Cliente de LoL esté abierto.', port: null, token: null };
    }

    // El resto de la lógica de lectura y parsing
    try {
        const data = fs.readFileSync(lockfilePath, 'utf8');
        // El lockfile es un string como: [nombre]:[PID]:[PUERTO]:[TOKEN]:[PROTOCOL]
        const [name, pid, port, password, protocol] = data.split(':');
        
        if (!port || !password) {
            return { error: 'Lockfile incompleto. El cliente no está ejecutándose.', port: null, token: null };
        }
        
        // El token para la LCU es la contraseña codificada en Base64 con prefijo "riot:"
        return { port: parseInt(port, 10), token: Buffer.from(`riot:${password}`).toString('base64') };

    } catch (error) {
        return { error: `Error al leer lockfile en ${lockfilePath}: ${error.message}`, port: null, token: null };
    }
}

async function fetchLiveGameData() {
  const { port, token, error } = getLcuCredentials();

  if (error) return { data: null, error: true, message: error, gameTime: 0 };

  const LIVE_CLIENT_API_URL = `https://127.0.0.1:${port}/liveclientdata/allgamedata`;
  
  try {
    const response = await axios.get(LIVE_CLIENT_API_URL, {
      headers: {
        'Authorization': `Basic ${token}`
      },
      // CRÍTICO: Asegurarse de usar el agente global 'lcuAgent'
      httpsAgent: lcuAgent // Reemplaza 'new https.Agent({ rejectUnauthorized: false })' 
    });

    if (response.status === 200 && response.data) {
        if (response.data.gameData && response.data.gameData.gameTime !== undefined) {
            return { data: response.data, gameTime: response.data.gameData.gameTime, error: false };
        } else {
             return { error: true, message: 'Partida no iniciada. Esperando tiempo de juego.', gameTime: 0 };
        }
    }
    return { error: true, message: 'Respuesta inválida de LCU.', gameTime: 0, data: null };

  } catch (axiosError) {
    let message = `Fallo al conectar a LCU: ${axiosError.message}`;
    if (axiosError.response && (axiosError.response.status === 404 || axiosError.code === 'ECONNREFUSED')) {
      message = 'No hay partida activa (LCU API Not Found).';
    }
    return { error: true, message: message, gameTime: 0, data: null };
  }
}

// --- CRÍTICO: LÓGICA DE POLLING (FALTANTE) ---

async function sendLiveGameUpdate() {
    const token = 'NO_AUTH_REQUIRED'; 

    try {
        const { data: liveGameData, error, message, gameTime } = await fetchLiveGameData();

        if (error || gameTime < 10 || !liveGameData) { 
            console.log(`[POLLING] No hay partida activa o error. Mensaje: ${message}`);
            return;
        }

        const response = await axios.post(
            `${BACKEND_BASE_URL}${LIVE_GAME_UPDATE_ENDPOINT}`,
            liveGameData, 
            {
                headers: {
                    'Authorization': `Bearer ${token}`, 
                    'Content-Type': 'application/json',
                },
                httpsAgent: lcuAgent, 
            }
        );

        if (response.status === 200) {
            console.log(`[LIVE-DATA] Envío exitoso para GameTime: ${gameTime}`);
        } else {
            console.error(`[POLLING] Error al enviar datos: ${response.status}`);
        }
    } catch (error) {
        console.error('[POLLING ERROR]: Error al conectar/enviar al Backend: ', error.message);
    }
}

function startLiveCoachPolling() {
    if (pollingInterval) clearInterval(pollingInterval); 
    
    sendLiveGameUpdate(); // Ejecuta inmediatamente
    
    pollingInterval = setInterval(sendLiveGameUpdate, LIVE_GAME_UPDATE_INTERVAL);
    console.log(`[LIVE COACH] Polling iniciado. Enviando datos cada ${LIVE_GAME_UPDATE_INTERVAL / 1000}s.`);
}

function stopLiveCoachPolling() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
        console.log('[LIVE COACH] Polling detenido.');
    }
}


// --- LÓGICA DE VENTANA Y WEBSOCKET (CON IPC CORREGIDO) ---

function createOverlayWindow() {
  const { width, height } = screen.getPrimaryDisplay().workAreaSize;

  overlayWindow = new BrowserWindow({
    width,
    height,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    resizable: false,
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: false,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  overlayWindow.setIgnoreMouseEvents(true, { forward: true });

  const urlToLoad = isDev
    ? `${HTTP_BASE_URL}/overlay`
    : `file://${path.join(__dirname, 'out/overlay.html')}`; 

    if (isDev) {
      overlayWindow.loadURL(urlToLoad);
      // **IMPORTANTE: AÑADIDO PARA DEBUG**
      overlayWindow.webContents.openDevTools(); 
    } else {
      overlayWindow.loadFile(path.join(__dirname, 'out/overlay.html'));
    }
    
    ipcMain.handle('lcu:fetch-game-data', async () => { 
        return await fetchLiveGameData(); 
    });
}

function setupWebSocketClient() {
  wsClient = new WebSocket(WS_BASE_URL);

  wsClient.on('open', () => {
    console.log('[WS-CLIENT] Conectado al servidor WebSocket del backend.');
  });

  wsClient.on('message', (data) => {
    try {
      const message = JSON.parse(data.toString());
      console.log('[WS-CLIENT] Mensaje recibido del backend. Acción:', message.priorityAction); 

      // FIX CRÍTICO DE IPC: Usa un canal fijo y envía el mensaje completo
      if (overlayWindow) {
        overlayWindow.webContents.send('live-coach-update', message); 
      }
    } catch (error) {
      console.error('[WS-CLIENT] Error al procesar mensaje:', error);
    }
  });

  wsClient.on('close', () => {
    console.log('[WS-CLIENT] Desconectado del servidor WebSocket. Intentando reconectar en 5 segundos...');
    setTimeout(setupWebSocketClient, 5000); 
  });

  wsClient.on('error', (error) => {
    console.error('[WS-CLIENT] Error de WebSocket:', error.message);
  });
}

// --- LÓGICA DE ATAJOS Y ARRANQUE ---

function registerGlobalShortcuts() {
    globalShortcut.register('CommandOrControl+F1', () => {
        if (overlayWindow) {
            overlayWindow.setIgnoreMouseEvents(false);
            console.log('Shortcuts: Interacción HABILITADA (CTRL+F1).');
        }
    });

    globalShortcut.register('CommandOrControl+F2', () => {
        if (overlayWindow) {
            overlayWindow.setIgnoreMouseEvents(true, { forward: true }); 
            console.log('Shortcuts: Interacción DESHABILITADA (CTRL+F2).');
        }
    });
}


async function startApp() {
    const { default: Store } = await import('electron-store');
    store = new Store(); 

    createOverlayWindow();
    setupWebSocketClient();
    startLiveCoachPolling(); // CRÍTICO: Inicia el ciclo continuo
    registerGlobalShortcuts();
}


app.whenReady().then(startApp);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
  stopLiveCoachPolling(); 
});

app.on('will-quit', () => {
  globalShortcut.unregisterAll();
});